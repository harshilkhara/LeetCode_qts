# Approach 1- Bitwise prefixes in HashSet
def findMaximumXOR(nums):
	# length of max number in a binary representation
	L = len(bin(max(nums))) - 2
	max_xor = 0
	for i in range(L)[::-1]:
		# go to the next bit by the left shift
		max_xor <<= 1
		# set 1 in the smallest bit
		curr_xor = max_xor | 1
		# compute all existing prefixes 
		# of length (L - i) in binary representation
		prefixes = {num >> i for num in nums}
		# Update max_xor, if two of these prefixes could result in curr_xor.
		# Check if p1^p2 == curr_xor, i.e. p1 == curr_xor^p2
		max_xor |= any(curr_xor^p in prefixes for p in prefixes)
	        
	return max_xor

# Approach 2- Bitwise Trie 
def findMaximumXOR1(nums):
	 # Compute length L of max number in a binary representation
	L = len(bin(max(nums))) - 2
	# zero left-padding to ensure L bits for each number
	nums = [[(x >> i) & 1 for i in range(L)][::-1] for x in nums]

	max_xor = 0
	trie = {}
	for num in nums:
	    node = trie
	    xor_node = trie
	    curr_xor = 0
	    for bit in num:
	        # insert new number in trie
	        if not bit in node:
	            node[bit] = {}
	        node = node[bit]
	        
	        # to compute max xor of that new number 
	        # with all previously inserted
	        toggled_bit = 1 - bit
	        if toggled_bit in xor_node:
	            curr_xor = (curr_xor << 1) | 1
	            xor_node = xor_node[toggled_bit]
	        else:
	            curr_xor = curr_xor << 1
	            xor_node = xor_node[bit]
	            
	    max_xor = max(max_xor, curr_xor)

	return max_xor

print(findMaximumXOR([3,10,5,25,2,8]))
print(findMaximumXOR1([3,10,5,25,2,8]))